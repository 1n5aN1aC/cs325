Pre-explanation: Merge&Count works by simply running mergesort on the list, and counting how many times elements are inverted.  Mergesort works (code actually flows in the other direction, as it is recursive, however it makes more sense conceptually this way) by splitting the Length N list into n separate elements, then continues to combine those into n/2 lists of 2n length.  It does this by comparing the existing 'lists' (singlets) and moving the smallest of the first elements of either list into the new list, thereby sorting them.

Proof by contradiction:
Assume that one of the resulting lists is incorrect.  If one of the lists obtained by combining smaller lists was not sorted, then mergesort would no longer work, and therefore the inversion counting would also be incorrect.  The only way for this to happen is for the smaller sub-lists to be incorrectly sorted, (since we assume they are sorted, and only look at the first elements in either) and the only way for those to be incorrectly sorted is if exactly what we are talking about right now is true.  Eventually we get to the base case, where each sub-list is only 1 element, but it is impossible to mess this up, since there is no way for a single-element list to not be sorted.
